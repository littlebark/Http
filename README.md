# Http
### 图解http
#### tcp/ip协议
* 应用层  
  决定了向用户提供应用服务时通信的活动,HTTP 协议也处于该层(HTTP客户端/服务器,DNS)
* 传输层  
  传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输(TCP/UDP)

* 网络层  
用来处理在网络上流动的数据包。数据包是网络传输的最小数
据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计
算机，并把数据包传送给对方。  (IP)
* 数据链路层
用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱
动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等
物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在
链路层的作用范围之内。 (网络) 

发送端每一步加一层各层对应的部首，到达接收端后则去除部首，这个过程叫封装

class应用层
	http数据  
	
class传输层
	private应用层
	tcp部首  
	
class网络层
	private传输层
	ip部首  
	
class链路层
	private网络层
	以太网部首  
	
**IP是网络协议，和ip地址不一样。**
IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方
那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC
地址  
TCP 三次握手：发送SYN/ACK，对面接收到，返回SYN/ACK，我方接收到，发送ACK确认消息。
访问一个url所做的事：DNS负责将域名解析为ip，http协议生成针对目标web服务器的http请求报文，tcp协议
将报文分割多段，以顺序可靠的发送给对面(期间进行三次握手)，ip协议搜索地址，一边中转一边传送，
接收端tcp协议,顺序重组，接收端http协议，对web请求内容处理，将请求结果同样发回。

#### HTTP 是不保存状态的协议
为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设
计成如此简单的。
后来为了保存登录用户名密码等数据，引入了cookie技术。
常见方法： 
>  
get：请求资源   
post：传输实体主体  
put：传输文件，因为不带验证机制，所以一般不用这方法  
HEAD：获得报文首部  
delete：删除文件，与put一样不用，rest时可能开放  
option：询问支持的方法  
trace：追踪路径。容易引发xst(跨站追踪)，不怎么用  
connect:要求使用隧道协议连接代理  
以上方法都用大写 
*** 

在 HTTP/1.1 中，所有的连接默认都是持久连接


管线化，允许多个请求同时发送（加载多图片时可以一起加载，以前一个请求要收到应答后才能再发一个请求

Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的
首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器
发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出
去。
服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一
个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前
的状态信息。

### 通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。

### 范围请求
GET /tip.jsp HTTP/1.1
Host:www.usagidesign.jp
Range: bytes = 5001-10000
范围请求需要定义range部分，这也是断点续传的原理
> 针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。

### 状态码
- 10x:接收的请求正在处理
- 20x:请求正常处理完毕
	- 200：OK
	- 204:no content，请求处理成功，但是没资源返回
	- 206:partial content 范围请求
- 30x:需要进行附加操作以完成请求
	- 301: moved permanently,资源已经被永久的移到另一个地方
	- 302:found,资源临时被移动到新的uri，希望本次用新的uri访问
	- 303:see other，资源存在另一个uri，用get方法请求
	- 304:not modified,资源已找到，但未符合条件请求
	- 307:temporary redirect,临时重定向
- 40x:服务器无法处理请求(客户端错误)
	- 400:bad request,语法错误等错误请求
	- 401:unauthorized,需要认证
	- 403:forbidden,服务器拒绝，未授权访问等
	- 404:not found,找不到资源，或者服务器拒绝并不想说明情况等
	
- 50x:服务器处理出错
	- 500：internal server error:服务器出错
	- 503: service unavailable,超载或停机，不可用
## 通用笔记 ##
### 6.27 ###
1. 注解
    关键字@interface
    注解里可以定义各种基本类型的属性（类，数组）
2. 注解的使用
    反射。
    核心在于class，field，method等都继承了注解的接口AnnotationElement。
    使用时，可以用这个接口很方便的获取一个类的方法，字段，类上是否标记了注解。
    如果标记了，则实例化该注解，获得注解的属性，然后设置给这个反射获得的类的实例。
3. 一句话解释设计模式六大原则<br>
    a:单一职责。把功能分工，特定的类只干特定的事。
    b:开放封闭原则。利用抽象，对功能的变动，不改原代码，通过新增代码解决问题。
    c:里式替换原则。所有父类能出现的地方，用子类替代也能正常运行。子类重写的方法入参要比父类宽松。比如父类入参是HashMap，子类入参可以是map。这样就可以替代。<br>
    d:依赖倒置。核心就是面向接口编程。
    e:接口隔离原则。把不同功能分给不同的接口，让实现类避免少了解与己无关的方法、通过实现不同接口保证与外部的耦合；
    f:迪米特原则。一个类对自己需要耦合或调用的类知道的最少，你(被耦合或调用的类)的内部是如何复杂和我没有关系，我就知道你提供的public方法，我只调用这些方法，其它的我不关心。只与直接朋友通信
### 7.15 ###
#### servlet ####
正常我们实现请求是要写很多Servle实现类来继承HTTPServlet，然后web.xml做如下配置，请求由Url-pattern进入，然后到对应的类。
`
<servlet>
        <servlet-name>HelloWorld</servlet-name>
        <servlet-class>HelloServlet</servlet-class>
</servlet>
`
`<servlet-mapping>
        <servlet-name>HelloWorld</servlet-name>
        <url-pattern>/HelloWorld</url-pattern>
    </servlet-mapping>
`
有了SpringMVC后，他就一个Servlet，请求到了SpringMVC对应的DispatcherServlet，他再去转发。
### 7.16 ###
#### interrrupt() ####
1. 如果线程是处于阻塞状态的，调用interrupt()会让线程中断标志为true。抛出InterruptedException，并且将状态设置成false.<br>
2. 如果线程不是阻塞状态的，他仅仅是标记成true，后续工作还需要程序自己处理。
比如，用if或者while不断判断isInterrupted()然后再做决策。

	
